"""
Cavity model module. This module contains the CavityModel class which can be used to solve for the
steady state photon number in a cavity lattice.

@author: Alex Carney
"""

import numpy as np
import matplotlib.pyplot as plt
import sympy as sp


class CavityModel:
    def __init__(self,
                 cavity_adj_matrix: np.ndarray,
                 gamma_vector: np.ndarray,
                 J_val: float,
                 wf_sweep: np.ndarray,
                 wc_vector: np.ndarray):
        """
        This function initializes the CavityModel class.
        :param cavity_adj_matrix: The adjacency matrix of the cavity lattice.
        :param gamma_vector: The decay rate each cavity site.
        :param J_val: The coupling strength of the cavity lattice.
        :param wf_sweep: The frequency sweep of the cavity lattice.
        :param wc_vector: The cavity frequencies of the cavity lattice.
        """

        # Constructor parameters
        self.J_val = J_val
        self.cavity_adj_matrix = cavity_adj_matrix
        self.gamma_val = gamma_vector
        self.wf_sweep = wf_sweep
        self.wc_vector = wc_vector

        # Autogenerated parameters
        self.num_cavities = len(cavity_adj_matrix)

        # Define symbolic variables needed for multiple functions - internal use only
        self.J = sp.symbols('J', real=True)
        self.wf_vector = sp.Matrix(self.num_cavities, 1, [sp.symbols('w_f', real=True)] * self.num_cavities)
        self.w_vector = sp.Matrix\
            (sp.symbols('w_c:{}'.format(self.num_cavities), real=True)).reshape(self.num_cavities, 1)
        self.gamma_vector = sp.Matrix(
            sp.symbols('gamma_:{}'.format(self.num_cavities), real=True)).reshape(self.num_cavities, 1)
        self.symbolic_adjacency_matrix = sp.Matrix(self.cavity_adj_matrix).applyfunc(lambda x: self.J * x)

        # Public - combine input cavity dynamics matrix with symbolic variables
        self.cavity_dynamics_matrix = (self.symbolic_adjacency_matrix * -1j) + sp.diag(
            *(self.gamma_vector + 1j * (self.wf_vector - self.w_vector)))

    def cavity_steady_state(self, drive_vector: np.ndarray) -> callable:
        """
        This function solves for the steady state photon number in a cavity lattice, and plots it as a function of wf
        :param drive_vector: A COLUMN VECTOR representing the drive on each cavity. Must be of size [N x 1]
        :return: A function (callable) that can be used to find the steady state photon number as a function of wf.
        """

        # Define drive vector
        F_vector = sp.Matrix(sp.symbols('F_:{}'.format(self.num_cavities), real=True)).reshape(self.num_cavities, 1)

        steady_state_eqns = self.cavity_dynamics_matrix.inv() * F_vector

        # Perform substitution of all symbolic variables with their numerical values:
        # Define a dictionary of all symbolic variables and their numerical values
        symbolic_variable_dict = {}
        # Cavity frequencies
        symbolic_variable_dict.update({
            self.w_vector[i]: self.wc_vector[i][0] for i in range(self.num_cavities)
        })
        # Cavity dissipation - single value for now
        symbolic_variable_dict.update({
            self.gamma_vector[i]: self.gamma_val[i][0] for i in range(self.num_cavities)
        })
        # Cavity drives
        symbolic_variable_dict.update({
            F_vector[i]: drive_vector[i][0] for i in range(self.num_cavities)
        })
        symbolic_variable_dict.update({
            self.J: self.J_val,
        })
        # Perform massive substitution
        steady_state_response_to_freq_sweep = steady_state_eqns.subs(symbolic_variable_dict)
        # So much more complicated...
        steady_state_response_to_freq_sweep = sp.lambdify(self.wf_vector[0], steady_state_response_to_freq_sweep,
                                                          modules='numpy')

        return steady_state_response_to_freq_sweep
        # steady_state_response_to_freq_sweep = steady_state_response_to_freq_sweep.lambdify()

    def plot_steady_state(self, complex_photon_response: np.ndarray, plot_title_info: str = "") -> None:
        """
        Plot the occupancy of each cavity in steady state. Requires running cavity_steady_state first.
        :param plot_title_info: Additional information to pass into the title
            of the plot (e.g. drive strength) - optional param (default = "")
        :param complex_photon_response: Output from cavity_steady state
        :return: Plot of the steady state photon number in each cavity.
        """
        # Choose post processing - abs, real, squared?
        abs_photon_response = np.abs(complex_photon_response)

        # Numpy edge case
        if np.ndim(abs_photon_response) == 1:
            plt.plot(self.wf_sweep, abs_photon_response)
        else:
            num_rows = abs_photon_response.shape[0]
            # plot each row as a separate line
            # only plot cavity 2

            plt.plot(self.wf_sweep, abs_photon_response[1, :])
            # for i in range(num_rows):
            #     plt.plot(self.wf_sweep, abs_photon_response[i, :])

        # add axis labels and legend
        plt.xlabel('wf sweep (freq)')
        plt.ylabel('Photon Number (arb)')
        plt.legend(['Photon # Cavity {}'.format(i + 1) for i in range(abs_photon_response.shape[0])])
        plt.title("Cavity Occupancy by Driving Frequency" + plot_title_info)
        plt.show()


if __name__ == '__main__':
    # Example
    # simple_adj = np.array([[0, 1], [1, 0]])
    # simple_adj = np.array([[0, (np.sqrt(2) - 1)], [(np.sqrt(2) + 1), 0]])
    #simple_adj = np.array([[0, 1], [1, 0]])
    # simple_adj = np.array([[0, 1], [1, 0]])
    phase_val = 1.5
    simple_adj = np.array([[0, np.exp(1j * phase_val)], [1, 0]])
    wf_sweep = np.r_[6.4:8.0:.001]
    #cavity_freqs = np.array([[4.42], [4.42]])
    cavity_freqs = np.array([[7.0167], [7.0123]])
    #cavity_freqs = np.array([[6.6], [7.6]])
    single_cavity_drive = np.array([[1], [0]])
    gamma_experimentally_fitted = np.array([[.01], [.01]])
    J_experimentally_fitted = .2

    cm = CavityModel(simple_adj, gamma_experimentally_fitted, J_experimentally_fitted, wf_sweep, cavity_freqs)
    print("starting")

    ssr = cm.cavity_steady_state(single_cavity_drive)
    complex_response = ssr(wf_sweep)
    complex_response = np.squeeze(complex_response, axis=1)

    # now use my plot function
    # Whatever works
    SCALE_FACTOR = 9e-6
    cm.plot_steady_state(complex_response * SCALE_FACTOR, " gamma = " + str(gamma_experimentally_fitted))

    # cm.plot_steady_state(sum(np.abs(complex_response * SCALE_FACTOR)))


    # Add in a phase sweep - te^j(theta) on the top right
    # te^-j(theta) on the bottom left