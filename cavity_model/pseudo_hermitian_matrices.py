"""
Pseudo Hermitian Matrix module. This module contains the PseudoHermitianMatrix class which can be used to generate
any arbitrary 2x2 pseudo-hermitian matrix.

@author: Alex Carney
"""

import numpy as np
import sympy as sp


class PseudoHermitianMatrix:
    def __init__(self,
                 epsilon: float,
                 gamma: float,
                 rho: float,
                 alpha: float,
                 theta: float,
                 phi: float):
        """
        This function initializes the PseudoHermitianMatrix class.
        :param self:
        :param matrix:
        :return:
        """

        # Constructor parameters
        self.epsilon = epsilon
        self.gamma = gamma
        self.rho = rho
        self.alpha = alpha
        self.theta = theta
        self.phi = phi

        # Autogenerated parameters
        # create variables for all of the inputs, but they are symbolic
        self.epsilon_var = sp.symbols('epsilon', real=True)
        self.gamma_var = sp.symbols('gamma', real=True)
        self.rho_var = sp.symbols('rho', real=True)
        self.alpha_var = sp.symbols('alpha', real=True)
        self.theta_var = sp.symbols('theta', real=True)
        self.phi_var = sp.symbols('phi', real=True)

        # Now, create the matrix

        # I split up the generation of the matrix to make it easier for myself. This part can be omitted while reading
        # Define vectors defined in bold in the paper (Eqn 88)
        n1 = sp.Matrix([sp.sin(self.theta_var) * sp.cos(self.phi_var), sp.sin(self.theta_var) * sp.sin(self.phi_var),
                       sp.cos(self.theta_var)])
        n2 = sp.Matrix([sp.cos(self.theta_var) * sp.cos(self.phi_var), sp.cos(self.theta_var) * sp.sin(self.phi_var),
                       -sp.sin(self.theta_var)])
        n3 = sp.Matrix([-sp.sin(self.phi_var), sp.cos(self.phi_var), 0])

        px = np.array([[0, 1], [1, 0]])
        py = np.array([[0, -1j], [1j, 0]])
        pz = np.array([[1, 0], [0, -1]])

        Mvecterm = self.gamma_var * n1 + 1j * self.rho_var * sp.sin(
            self.alpha_var) * n2 + 1j * self.rho_var * sp.cos(self.alpha_var) * n3

        Maddterm = self.epsilon_var * np.identity(2)

        # Now, create the matrix
        general_form = sp.Matrix(Maddterm + (np.conj(Mvecterm[0] * px)
                                             + (np.conj(Mvecterm[1] * py)
                                                + (np.conj(Mvecterm[2] * pz)))))

        # Now, substitute in the values for the variables
        # pull out that dictionary into its own definition
        subs_dict = {self.epsilon_var: self.epsilon, self.gamma_var: self.gamma, self.rho_var: self.rho,
                     self.alpha_var: self.alpha, self.theta_var: self.theta, self.phi_var: self.phi}

        self.matrix = general_form.subs(subs_dict)
        n1_subbed = n1.subs(subs_dict)

        self.matrix_class = (px * np.conj(n1_subbed[0])) + (py * np.conj(n1_subbed[1])) + (pz * np.conj(n1_subbed[2]))

if __name__ == '__main__':

    # Note, if you want to use this module, you can just import it and use the class. The code below is just for testing
    # Also be aware that the matrix is stored as a sympy matrix,
    # So you will need to convert it to a numpy array if you want

    # Additionally, you can represent the eigenvalues of the matrix with the equation:
    # lambda = epsilon + sqrt(gamma^2 - rho^2)
    # Therefore, if rho > gamma, the eigenvalues are complex

    # Example 1: Degenerate eigenvalues (exceptional point)
    degenerate = PseudoHermitianMatrix(4, 1, 1, 0, 0, 0)

    # Example 2: Near parallel eigenvectors (right next to an exceptional point)
    near_parallel = PseudoHermitianMatrix(4, 1.01, 1, 0, 0, 0)

    # Example 3: All real + positive matrix elements
    real_positive = PseudoHermitianMatrix(4, 2, 1, 0, sp.pi/4, 0)

    # Example 4: Unidirectional lattice with equal resonances - Also an exceptional point (degenerate eigenvalues)
    unidirectional = PseudoHermitianMatrix(4, 2, 2, 0, sp.pi/2, 0)

